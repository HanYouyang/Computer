
﻿1
00:01:33,800 --> 00:01:37,800
a 数组用来表示整数的每一位。
倒着存，a[0] 表示个位，a[1] 表示十位，a[2]表示百位,...
数组长度200+1
构造函数中对变量清0
我们约定用length=0的类来表示大整数0
length=0就代表了一个空的[函数->类]
重载方括号[]
每次程序运行到assert的时候都会强制检查是否越界
这个重载 [ ] 的函数是不能直接使用的
还要有一个const属性的成员[变量->函数]
从低位到到高位枚举每一位相加
增加一个成员变量表示负数
写一个比较函数 < 来判断被减数是否比减数小
如果被减数比减数要小
反过来减
开始写乘法
最后全部加起来！
大整数乘上一位小整数的 小乘法
重载左移运算符 << 来做十进制左移
枚举 [被乘数->乘数] 的每一位
枚举 乘数 的每一位
乘上 [被乘数->乘数] 的某一位（又说错了）
乘上 乘数 的某一位
注意了！
乘上 乘数的某一位 （又说错）
然后左移！
被乘数 乘上 b[i] 然后左移i位 累加
来啊！除法！
341 / 12
12 对齐到 341 的最高位
看看12乘多少会刚刚好比34 小
乘2刚好小 所以除法的最高位是2
用被除数减掉那个对齐的24
除数12 继续对齐 再尽可能的减
把除数和被除数的最高位对齐，尽可能减得多
用c来存结果。枚举位差
被除数的位数减掉除数的位数 就是除数要左移多少位
用tmpa 复制一份被除数 因为等会会改这个被除数
d = 把除数左移对齐后的数
while 被除数>=d 就尽可能的减掉d！
偷懒！
用小于号 < 来代替>=
尽可能减。每减一次，累加一个1 到c[i]
这样写除法会有（最多一个）前导0 （为什么？）
把减法里面 去除前导0 的那三行贴过来
只剩下一点点扫尾工作 就写完了~
从输入端 读入 输出 一个Num
打蚊子...
写两个函数来输入输出（偷懒）
最后是main函数
这里用 switch 是不是更好？（助教在复制粘贴 偷懒）
写完了开始编译
囧 好多编译错...
b - *this 的b 是const
但是成员函数不是const
const对象不能调用非const成员函数
把成员函数声明成const 
跪了 小于号重载也得是const
所有的函数参数都是 const Num &b
干脆把那些运算符函数都弄成const好了-_-..
思考：为什么参数要用const &
开始自己设计小数据做测试
好，1-1=0
1-2 = -1
9/2 = 4
纳尼！
在乘法函数里面把变量输出来看看
（废话 这个地方当然会挂）
应该是小乘法写错
Oh no! 没有初始化
wrong answer了-_-....
看看哪个数据错
debug开始！
多输了2位
到底哪里错了呢 -_-?
直接看是看不出来了
助教教你调代码~
把除法的每一位都输出来
找到问题了：怎么会有一位是19？
本来应该是2（减两次）我们多减了
本来减着减着就停下来的但是没有停
还有一个更狠的招数
把所有的减法步骤的中间结果也输出来！
定位到之前发现的那个出错 的地方
第一次减法：36xxx-12xxx = 24xxx
24xxx-12xxx = 11xxx
11xxx应该没法继续减了！
没停下来就是小于号判断有错
改完看起来好像是对的了
来战个痛！
yeah！
其实是小乘法的t没初始化成0
oh my god 终于录完了

