这道题也偏容易, 但要注意题目提示的那几种特殊情况. 这体现了思维是否严谨.

整数反转, 思路很简单, 原数的个位 ==> 结果的最高位. 原数的最高位 ==> 结果的个位. 那么循环一下吧?
```cpp
while (x)
{
  res = res * 10 + x % 10; // 加号前面是先取得的值保持最高位, 后面则是取得原数的个位.
  x /= 10; // 裁剪原数, 确保能够从低位到高位的值, 能够被依次取得.
}
```
这就是这道题的核心了.

------

特殊情况:

1. 后几位是0的情况(10, 100.)? 这个我们的循环已经考虑了, 如果原数的个位是0, res 则会一直保持是0, 直到非0的出现.
2. overflow的问题? 检测很简单, 将 res 设为 `long`, 那你一个 `int` 怎么反转都不会超出 `long` 的范围了吧? 然后判断 res 和 `INT_MAX`的关系就可以了.

缩减一下上面的循环. 答案有了.
