这道题的思路请参考：[04. Reverse Integer](../04. Reverse Integer)，Palindrome 的本质就是 reverse 之后还是自己。

-----

我看了下 04 的笔记，我觉得当时我描述这个思路时，跨越有点大。我承认，刚拿到这样的题，要求不用额外空间，的确有点一筹莫展。 reverse 最自然的思路就是拿到**最高位**，去和**最低位**比，然后依次往里推进。

但这个思路有一个前提，就是需要知道该数的位数，否则如何拿到最高位？在不用额外空间的情况下，我们完全无法迅速得知。

看似思路到这里就受阻了，但我们有两个基本的工具：循环、迭代，还没有派上用场，你觉得这正常吗？

循环的妙处就在于一下子得不到的东西，慢慢就能得到。我的确一下子无法拿到最高位，但如果我在循环里每次去掉最低位，最后剩下的结果是否就是最高位呢？

有人说，慢！可别忘了咱的目的，是要比较首尾，你费了半天劲拿到最高位，比较还需要循环呢。

的确，如果一次循环能够搞定，千万不要啰嗦。很显然，目前这种思路是无法一次迭代完成的，又受阻了。

不使用额外空间，我们使用一个临时的 build-in 类型总该可以吧？如果我们在迭代过程中记录每一次的最低位呢？

等等，Bingo! 记录的时候，不就可以将该数逆向存储了吗？一下子就有了下面的式子：

```cpp
long buf{0};
do {
    buf = buf * 10 + x % 10;
} while (x /= 10);
```

- 为啥用 do while ? 因为这样我以 `x /= 10` 作为循环条件，它会破坏 x 的值，所以为了个位可以被记录， do while 是一个好的选择。
- 为啥使用 long ? 因为我们并不知道一个 int 类型的数，reverse 之后会不会超出 MAX_INT。用 long 就避免了这样的疑虑。

思路是一个连续的过程，一旦发生了莫名其妙的跳跃，我想不是 google 的功劳，就是有个聪明的小子在旁边提示了他！

----

回到这道题，看一下 hints:

1. 负数可以是回文吗？不行， -1 你觉得它对称吗？ 有 -1- 这样的数字吗，这才算回文。
2. 别试图使用字符串
3. reverse 的时候注意溢出。

对于1， 我们可以一上来就判断： `if (x < 0) return false;`， 对于3，使用 long 回避。

AC，不好意思用了6行。。
