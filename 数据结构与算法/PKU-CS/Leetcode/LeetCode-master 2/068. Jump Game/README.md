今天在外转了一天，过的太丰富，竟然没时间来上传代码。但这道题却很早就解出来，手机上AC了。总共才三行代码。

第一步，能够决定什么？决定你最远可以走到哪。细细想一下，咱们的大脑是如何判断 true or false 的：

    [2,3,1,1,4]
    // 先走 1 步，看到 3，走 3 步，发现到底，`true`
    [3,2,1,0,4]
    // 先走 1 步，看到 2，走 2 步，发现到 0，无法到底。
    // 走 2 步，看到 1， 走 1 步，发现到 0，无法到底。
    // 走 3 步，看到 0，无法到底。`false`

我们可以看到一个基本的迭代。
```cpp
for (int i=0; i<n; ++i)
```

但我们也很容易看出，我们没有一次是真正迭代到 n-1 的，我们无需走完，就可以得到结论。为何？

因为，第一步，完全可以决定你最远走到哪，如第二个数组，你永远也无法达到 n-1。

故，这是一个不断累积计算最大值的问题，我们显然需要需要记录当前可以达到的最远距离，记为 max:
```cpp
for (int i=0, max=0; i<n && i<=max; ++i)
    max = std::max(max, i+A[i]);
```

但从第一个数组的判断过程中，还可以得知，我们甚至连这个最大值都无需走到，因为，只要 max >= n-1
就完全可以说明 true 了。
```cpp
for (int i=0, max=0; i<=max; ++i)
    if ((max = std::max(max, i+A[i])) >= n-1) return true;
return false;
```

这三行代码，如实的表述了咱们大脑的思维过程，提交一下，发现效率也不低。但很抱歉，我说不出这叫什么算法。有识之士请指正之。
