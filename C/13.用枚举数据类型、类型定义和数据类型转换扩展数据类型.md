## 13用枚举数据类型、类型定义和数据类型转换扩展数据类型
本章主要讨论编译器在转换表达式中的数据类型时使用的准确规则。本章包括：

1. 使用枚举数据类型
2. 用typedef语句为C语言中的已有数据类型创建自己的标签
3. 将现有数据类型转换为其他类型

### 13.1枚举数据类型
主要考虑到限制数据类型存储值的类型。

**枚举数据类型**以关键字enum开头，紧跟数据类型的名字，其后是一份放在大括号中的标识符清单，清单限制了该类型允许的取值。

枚举类型被编译器看做整形常数。其实内在总是默认值按照索引赋予数字。内在自定义之后会依次递增而不是按照原有数值（可以理解后面的值默认不可能重复）。**但是枚举标识符总可以重复出现值**。


利用类型转换运算符，可以明确将整数值付给枚举数据类型变量。


```c++
int monthvalue = 6;
thismonth = (enum month) (monthvalue -1);
```
此时thismonth值为5。

通常情况下枚举数据类型不要跟数值牵涉过多关系，仅仅是知道索引可以如此。

也可以类似结构体定义中的变化，可以省略数据类型的名字。

### 13.2typedef语句
typedef语句可以提高程序的可读性，相当于给数据类型换个名字。

通常情况下，可以与#define等价，但是灵活性更高，主要体现在派生数据类型的时候。


```c++
typedef char linebuf[81];
linebuf text, inputline;
```
等价于

```c++
char text[81], inputline[81];
```
但是此时不能够使用#define语句进行等价定义。



总之tyedef的定义规则：正常定义一个类型的变量，将变量处改为新的类型名，在定义前加typedef。

但是typedef只定义一种新的类型名，而不是定义新类型，编译器仍然看成原有数据类型。

### 13.3数据类型转换

```c++
average = (float) total / n;
```
执行运算的过程会将total先转换类型来确保进行正常运算。

C编译器两数操作转换顺序运行规则：

1. long double，另一个被转换，结果也返回此类型。
2. double，另一个被转换，结果也返回此类型。
3. float，另一个被转换，结果也返回此类型。
4. **_Bool、char、short int、bit field或枚举类型，自身转换为int。**
5. long long int，另一个被转换，结果也返回此类型。
6. long int，另一个被转换，结果也返回此类型。
7. int，另一个被转换，结果也返回此类型。

主要是考虑到强制转换中唯一存在的**提升**。

#### 13.3.1符号扩展
字符总可以被当做数值的情况下，需要考虑是否有符号要求，如果在ASCII字符集中，为了避免出现符号拓展上的情况，应该先声明字符变量为unsigned char，范围从0到255。


#### 13.3.2参数转换
**原型声明**是在函数定义出现之前，在程序开始位置设定的对函数返回值类型、函数名和参数列表进行声明的语句。


1. 编译器在编译过程中如果没有看到函数定义和原型声明，会默认函数返回int。
2. 缺乏函数参数类型的信息时，编译器会将_Bool、char或short转换为int, float转换为double。


最好不要出现这种自动转换的情况。

