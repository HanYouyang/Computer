## 5二叉树

**非线性结构**是至少存在一个数据元素可以有两个或者两个以上的直接前驱或直接后继。

### 5.1二叉树的概念

#### 5.1.1二叉树的定义和基本术语

**二叉树**由结点的有限集合构成，或为空集，或为由一个根节点及两棵互不相交、分别称作这个根的左子树和右子树的二叉树组成的集合。

二叉树一共有五种基本形态。二叉树的左右次序不能颠倒，二叉树与其他树的区别也在于此。

**根**是二叉树的唯一的起始结点。

**父节点**是二叉树中非根节点的唯一的前驱结点。

**根节点**是二叉树中唯一没有父节点的结点。

**左子节点**和**右子节点**是二叉树的两个后继结点。

**兄弟结点**是具有相同父结点的结点。

**度**是一个结点的子树个数。

**叶节点**是没有子结点的结点，度为0。

**内部结点**是除叶结点外的非终端结点。

**边**是父节点与子节点之间存在的一条有向连线。

**路径**是二叉树中的结点序列从起始到终止的边，起始结点是终止结点的**祖先**，反之则为**子孙**。

**路径长度**是路径中边的个数。

**子树**是切断结点与父节点的连接后，该节点与子孙构成的树。

**层数**是根节点到某个结点的路径长度。


#### 5.1.2满二叉树、完全二叉树、扩充二叉树

**满二叉树**是二叉树的任何结点，或为树叶，或左右子树非空。

**完全二叉树**是二叉树只有最下面两层结点度数小于2（结点数等于2则意味着左右子树全满），并且最下面一层的结点都集中在该层最左边的连续位置上。

完全二叉树的特点：

1. 叶节点只可能在层次最大的两层出现
2. 根节点到各个节点的路径长度综合在同结点数的二叉树中达到最小

**扩充二叉树**是在出现空子树的位置增加空树叶形成的二叉树。

度为1的位置增加一个空树叶，在树叶下面加两个空树叶。

扩充二叉树是满二叉树。新增树叶的个数等于原二叉树的结点个数加1。

**外部路径长度**是扩充二叉树的根到每个外部结点的路径长度之和，为E。

**内部路径长度**是扩充二叉树从根到每个内部结点的路径长度之和，为I。

E = I +2n，n是内部结点的个数。

#### 5.1.3二叉树的主要性质

**高度**是二叉树中层数最大的叶节点的层数加1。

**性质1. 在二叉树中，第i层最多有2^i个结点（i>=0）。**

**性质2. 深度为k的二叉树至多有2^(k+1)-1个结点。**

**性质3. 任何一棵二叉树，若其终端结点数为n0，度为2的结点数为n2，则n0 = n2 + 1。**

**性质4. 满二叉树定理：非空满二叉树树叶数目等于其分支结点数加1。**

**性质5. 满二叉树定理推论：一个非空二叉树的空子树数目等于其结点数加1。**

**性质6. 有n个结点(n > 0)的完全二叉树的高度为[log2(n+1)]，深度为[log2(n+1)] - 1。**

**性质7. 对于具有n个结点的完全二叉树，结点按层次由左到右编号，则对任一结点i(0 <= i <= n -1)：**

1. i > 0，父节点的编号为(i-1)/2
2. 当2i + 1 <= n - 1时，结点i的左子结点是2i + 1，否则结点i没有左子结点；当2i + 2 <= n - 2时，结点i的左子结点是2i + 2，否则结点i没有左子结点。
3. 当i为偶数且0 < i < n时，结点i的左兄弟结点是i - 1，否则结点i没有左兄弟；当i为奇数且i+1 < n时，结点i的右兄弟是结点i + 1，否则结点i没有右兄弟。

### 5.2二叉树的周游



二叉树用结点存储必要的信息，对操作和运算也主要在访问结点信息上。

抽象数据类型与存储无关。

**代码5.1 二叉树结点的抽象数据类型**


```c++

```

**代码5.2 二叉树的抽象数据类型**



```c++

```

**二叉树的遍历**是指按照一定顺序依次访问书中的所有结点，并使得每个结点仅被访问一次。

**访问**指操作，包括对数据成员的输出、修改结点信息等。



对于线性结构可以很好地进行遍历，但是二叉树是一个非线性结构，所以遍历二叉树的过程实际上就是把二叉树的结点放入一个线性序列的过程，即对二叉树进行线性化。

#### 5.2.2深度优先遍历二叉树

**深度优先遍历算法**是尽可能延分支结点向深度方向进行遍历。

**二叉树的深度优先遍历**是先沿着分支结点向左下降，当遇到左子树为空时，返回到上面最近的且其右子树尚未访问到的分支结点，转向该分支结点的右子结点，然后再尽可能地沿着左链前进，直到遍历完所有的节点为止。


根据二叉树的递归定义，可以用递归算法来实现二叉树的遍历。

按照先左后右的遍历方法，3种深度优先周游是：

1. 前序法：根左右
2. 中序法：左根右
3. 后序法：左右根


**代码5.3 深度优先遍历二叉树或其子树**


```c++

```


