## 6.1多态和虚函数的基本概念

面向对象中的“多态”，决定了“面向”



类中，virtual关键字 成员函数，就是虚函数

但是只出现定义中，写函数体不需要这些。



派生类指针可以赋给基类指针（之前的public类引用规则）

调用时候，**指针指向哪里，就用哪个的虚函数**

派生类也可以给基类引用，也如同上面

## 6.2使用多态的游戏程序实例

非多态每个都要对应新的类产生具体的函数

但是此时加上虚函数，多态之后就可以得到函数

也就是每一个都可以继承了之后调用



此时原有的类当中，本身互相之间的关系，是用派生类指针赋值给基类的指针

然后用基类指针调用虚函数

此时指针指向谁，也就在调用于谁



## 6.3更多多态程序示例

几何形体处理

对每种形体进行虚函数定义



建立基类指针的数组后，每个在里面读到自己的状态，最终将每种类型的派生类指针定以后，赋值给基类指针，再调用虚函数，则指向的时候调用的是各种类型的虚函数



此时用MyCompare排序的时候，是对各个之前建立的基类指针数组中的内容进行排序。

而后建立的排序就应该用qsort当中的建立好的此时是指向指针的指针，而后得到具体指向几个基类的指针的内容。



在非构造非析构中的调用函数，就是多态

也因为构造和析构在初始化过程中完全不会等调用的时候再说



派生类中，与基类同名通参数表得到的函数不加virtual也是虚函数



## 6.4多态实现原理

编译的时候并不确定，指针调用的到底是基类还是派生类的函数

运行时候才能确定，**动态联编**



带有虚函数的类体积都增大了4

实际上有一个**虚函数表**，作为一个指针指向虚函数的地址



## 6.5虚析构函数

把基类的析构函数声明为virtual

派生类的析构函数不声明，此时

如有出现基类指针指向派生类对象并且删除的时候

那么就会有此时先调用派生类析构在调用基类析构



只要定义了虚函数，那么析构函数最好就定义为虚函数





## 6.6纯虚函数和抽象类

没有函数体的虚函数，**纯虚函数**

包含纯虚函数的类就是**抽象类**

此时只能做基类，也不能创对象，但是可以定义指针和引用

（作为指针调用派生类指针）



抽象类中：

成员函数可以调用纯虚函数

析构和构造函数内部是不可以的



类从抽象类派生而来：

必须得实现所有基类中的纯虚函数才能成为非抽象类
